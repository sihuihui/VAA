---
title: "Hands-on Exercise 8: Modelling, Visualising and Analysing Network data with R"
author: "Goh Si Hui"
date: 2024/03/03
execute: 
  echo: true
  eval: true
  freeze: true
  warning: false
  message: false
---

# About this Exercise

In this hands- on exercise, we will learn how to model, analyse and visualise network data using R. In particular, we will learn how to:

-   create graph object data frames, manipulate them using appropriate functions of **dplyr**, **lubridate** and **tidygraph,**
-   build network visualisation using appropriate functions of **ggraph,**
-   compute network geometrics using **tidygraph**,
-   build advanced graph visualisation by incorporating the network geometrics, and
-   build interactive network visualisation using **visNetwork** package.

# Getting Started

Before we start, let us ensure that the required R packages have been installed and import the relevant data for this hands-on exercise.

## Installing and Loading R Packages

For this exercise, other than tidyverse and lubridate, we will use the following packages:

-   [igraph](https://r.igraph.org/):Routines for simple graphs and network analysis. It can handle large graphs very well and provides functions for generating random and regular graphs, graph visualization, centrality methods and much more.

-   [tidygraph](https://tidygraph.data-imaginist.com/):provides a tidy API for graph/network manipulation. 

-   [ggraph](https://ggraph.data-imaginist.com/):an extension of ggplot2 aimed at supporting relational data structures such as networks, graphs, and trees.

-   [visNetwork](https://datastorm-open.github.io/visNetwork/):for network visualization, using vis.js javascript library

The code chunk below uses p_load() of pacman package to check if the abovementioned packages are installed in the computer. If they are, they will be launched in R. Otherwise, pacman will install the relevant packages before launching them.

```{r}

pacman::p_load(tidyverse, lubridate, igraph, tidygraph, ggraph, visNetwork)
```

## Importing Data into R
The data sets used in this hands-on exercise are from an oil exploration and extraction company. There are two data sets: one data set contains the nodes data and the other contains the edges (also know as link) data. We will import them using `read_csv()` of **readr** package. 

:::{.panel-tabset}
## node 
```{r}
node <- read_csv("data/GAStech_email_node.csv")
head(node)

```
GAStech_email_nodes.csv consist of the name, department and title of the employees.

## edge 
```{r}
edge <- read_csv("data/GAStech_email_edge-v2.csv")
head(edge)

```
GAStech-email_edges.csv consists of emails correspondances between the employees.
:::


# Data Checks 
We will now examine the structure of the data frame using `glimpse()` of **dplyr**. 

:::{.panel-tabset}
## node 
```{r}
glimpse(node)

```

## edge 
```{r}
glimpse(edge)

```
:::

:::{.callout-note}
## Observations
-   From the node table, we see that each employee is given an `id`, which is then used as the `source` and `target` for the edge table. 

-   the edge table's `SentDate` consists of date but it is treated as characters. We should change it to date data type. 

:::

```{r}
edge <- edge %>%
  mutate(SentDate = dmy(SentDate)) %>%
  mutate(Weekday = wday(SentDate,
                        label = TRUE,
                        abbr = FALSE))

glimpse(edge)
```

:::{.callout-note}
## Observations
-   `SentDate` is now a Date data type after we use `dmy()` to transform the `SentDate`.

-   A new column `Weekday` has been created using `wday()`, which returns the day of the week as a decimal number or an ordered factor if label is TRUE. The argument abbr is FALSE keep the daya spells in full, i.e. Monday. 

:::

A close examination of edge data frame reveals that it consists of individual e-mail flow records. This is not very useful for visualisation.Hence, we will aggregate the individual by date, senders, receivers, main subject and day of the week. 

```{r}
edge_aggregated <- edge %>%
  filter(MainSubject == "Work related") %>%
  group_by(source, target, Weekday) %>%
  summarise(Weight = n()) %>%
  filter(source != target) %>%
  filter(Weight > 1) %>%
  ungroup()

glimpse(edge_aggregated)
```

:::{.callout-note}
## Observations
-   We filtered those "Work related" emails using `MainSubject`. Then perform group_by using the source, target and Weekday. Then we create a new field `Weight` by counting the number of emails resulting from the group_by. We also remove those emails where the source and target are the same employees and those weights that are less than 1 to get the resultant table `edge_aggregated`. 
:::


# Creating network objects using tidygraph 

In this section, we will learn how to create a graph data model by using tidygraph package. It provides a tidy API for graph/network manipulation. While network data itself is not tidy, it can be envisioned as two tidy tables, one for node data and one for edge data. tidygraph provides a way to switch between the two tables and provides dplyr verbs for manipulating them. Furthermore it provides access to a lot of graph algorithms with return values that facilitate their use in a tidy workflow.

## tbl_graph object 
Graphs and networks can come from many sources, or be created by simulation or deterministacally. Tidygraph provides conversions from all well-known structures in R, as well as a range of create_() and play_*() functions for creating well-defined or simulated graphs.

We can make use of `tbl_graph()` and `as_tbl_graph()` to create network objects. 

-   `tbl_graph()` creates a tbl_graph network object from nodes and edges data. 
-   `as_tbl_graph()` converts network data and objects to a tbl_graph network. Below are network data and objects supported by `as_tbl_graph()`

  -   a node data.frame and an edge data.frame,
  -   data.frame, list, matrix from base,
  -   igraph from igraph,
  -   network from network,
  -   dendrogram and hclust from stats,
  -   Node from data.tree,
  -   phylo and evonet from ape, and
  -   graphNEL, graphAM, graphBAM from graph (in Bioconductor).

## dplyr verbs in tidygraph
-   `activate()` verb from tidygraph serves as a switch between tibbles for nodes and edges. All dplyr verbs applied to tbl_graph object are applied to the active tibble.
-   `.N()` function is used to gain access to the node data while manipulating the edge data.
-   `.E()` function is used to gain access to the edge data. 
-   `.G()` function is used to give us the tbl_graph object itself. 

## Building tidygraph data model 
In this section, we will use `tbl_graph()` of tinygraph package to build an tidygraph’s network graph data.frame.

```{r}

graph <- tbl_graph(nodes = node,
                   edges = edge_aggregated,
                   directed = TRUE)

graph 
```

:::{.callout-note}
## Observations
-   The output above reveals that GAStech_graph is a tbl_graph object with 54 nodes and 4541 edges.
-   The command also prints the first six rows of “Node Data” and the first three of “Edge Data”.
-   It states that the Node Data is active. The notion of an active tibble within a tbl_graph object makes it possible to manipulate the data in one tibble at a time.

:::

## Changing the active object 
The nodes tibble data frame is activated by default, but you can change which tibble data frame is active with the activate() function. Thus, if we wanted to rearrange the rows in the edges tibble to list those with the highest “weight” first, we could use activate() and then arrange().


```{r}
graph %>% 
  activate(edges) %>%
  arrange(desc(Weight))

```

# Plotting Static Network Graphs using ggraph 

ggraph is an extension of ggplot2, making it easier to carry over basic ggplot skills to the design of network graphs.

As in all network graph, there are three main aspects to a ggraph’s network graph, they are:

-   The Layout defines how nodes are placed on the plot, that is, it is a conversion of the relational structure into an x and y value for each node in the graph. ggraph has access to all layout functions available in igraph and furthermore provides a large selection of its own, such as hive plots, treemaps, and circle packing.
-   The Nodes are the connected entities in the relational structure. These can be plotted using the geom_node_*() family of geoms. Some node geoms make more sense for certain layouts, e.g. geom_node_tile() for treemaps and icicle plots, while others are more general purpose, e.g. geom_node_point().
-   The Edges are the connections between the entities in the relational structure. These can be visualized using the geom_edge_*() family of geoms that contain a lot of different edge types for different scenarios. Sometimes the edges are implied by the layout (e.g. with treemaps) and need not be plotted, but often some sort of line is warranted.


## Plotting a basic network graph
The code chunk below uses `ggraph()`, `geom-edge_link()` and `geom_node_point()` to plot a network graph by using `graph` which is the tbl_graph object that we created in previous section. 
```{r}
ggraph(graph) +
  geom_edge_link() +
  geom_node_point()

```

:::{.callout-note}
-   The basic plotting function is `ggraph()`, which takes the data to be used for the graph and the type of layout desired. 
-   Both of the arguments for `ggraph()` are built around igraph. Therefore, `ggraph()` can use either an igraph object or a tbl_graph object.

:::

## Customising ggraph's network graphs
We can use ggraph's `theme_graph()` to further customise our network graph. This `theme_graph()` is tuned for graph visualisations because the coordinate values are often of no importance  and axes are thus a distraction. Hence, ggraph has `theme_graph()`, a built-in theme to remove redundant elements. Furthermore the default behaviour is to use a narrow font so text takes up less space. Theme colour is defined by a background and foreground colour where the background defines the colour of the whole graphics area and the foreground defines the colour of the strip and border. By default strip and border is turned off as it is an unnecessary element unless facetting is used. To add a foreground colour to a plot that is already using theme_graph the th_foreground helper is provided. In order to use this appearance as default use the set_graph_style function. An added benefit of this is that it also changes the default text-related values in the different geoms for a completely coherent look. unset_graph_style can be used to revert the defaults back to their default settings (that is, they are not necessarily reverted back to what they were prior to calling set_graph_style). The th_no_axes() helper is provided to modify an existing theme so that grid and axes are removed.


```{r}
#create the graph
g <- ggraph(graph) +
  geom_edge_link(aes()) +
  geom_node_point(aes())

#adding the theme
g + theme_graph()

```
### Changing the plot colour 

`theme_graph()` makes it easy to change the coloring of the plot.

```{r}
g <- ggraph(graph) + 
  geom_edge_link(aes(colour = 'grey50')) +
  geom_node_point(aes(colour = 'grey40'))

g + theme_graph(background = 'grey10',
                text_colour = 'white')
```

## Working with ggraph's layouts 
ggraph support many layout for standard used, they are: star, circle, nicely (default), dh, gem, graphopt, grid, mds, spahere, randomly, fr, kk, drl and lgl. Figures below and on the right show layouts supported by ggraph().


:::{.panel-tabset}
## Fruchterman and Reingold layout 

```{r}
g <- ggraph(graph, 
            layout = "fr") +
  geom_edge_link(aes()) +
  geom_node_point(aes())

g + theme_graph()

```
## star layout 

```{r}
g <- ggraph(graph, 
            layout = "star") +
  geom_edge_link(aes()) +
  geom_node_point(aes())

g + theme_graph()

```

## eigen layout 

```{r}
g <- ggraph(graph, 
            layout = "eigen") +
  geom_edge_link(aes()) +
  geom_node_point(aes())

g + theme_graph()

```

:::

## Modifying network nodes 
We can also define the colour each node by referring to their respective departments.

```{r}
g <- ggraph(graph, 
            layout = "nicely") + 
  geom_edge_link(aes()) +
  geom_node_point(aes(colour = Department, 
                      size = 3))

g + theme_graph()

```

:::{.callout-note}
## Observations 

-   geom_node_point is equivalent in functionality to geo_point of ggplot2. It allows for simple plotting of nodes in different shapes, colours and sizes. In the codes chnuks above colour and size are used.
:::

## Modifying Edges 
We can also modify the edges such that the thickness of the edges will be mapped with the Weight variable.

```{r}
g <- ggraph(graph, 
            layout = "nicely") +
  geom_edge_link(aes(width=Weight), 
                 alpha=0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = Department), 
                  size = 3)

g + theme_graph()

```

:::{.callout-note}

geom_edge_link draws edges in the simplest way - as straight lines between the start and end nodes. But, it can do more that that. In the example above, argument width is used to map the width of the line in proportional to the Weight attribute and argument alpha is used to introduce opacity on the line.
:::


## Creating Facet Graphs 

### facet_edges() 


### facet_nodes() 


# Network Metrics Analysis 

## Computing Centrality Indices 

## Visualising Centrality Indices 

## Visualising Community 

# Building Interactive Network Graph with visNetwork 

## Data Preparation 

## Plotting the first interactive network graph 

## Working with layout 

## Working with visual attributes - Notes 

## Working with visual attributes - Edges 

## Interactivity 

# References 

