---
title: "Take-home Exercise 7a: Choropleth Mapping with R"
author: "Goh Si Hui"
date: 2024/02/25
date-format: long
date-modified: "last-modified"
format: html 
execute: 
  echo: true
  eval: true
  freeze: true
  warning: false
  message: false
editor: visual 
---

# About this Exercise 
In this exercise, we will learn how to plot functional and truthful choropleth maps using [tmap](https://cran.r-project.org/web/packages/tmap/) package. 

:::{.callout-note}
## What is choropleth mapping?

Choropleth mapping involves the symbolisation of enumeration units, such as countries, provinces, states, counties or census units, using area patterns or graduated colors. For example, a social scientist may need to use a choropleth map to portray the spatial distribution of aged population of Singapore by Master Plan 2014 Subzone Boundary.
::: 

# Getting Started 

## Installing and Loading R Packages

For this exercise, other than tmap, we will use the following packages:

-   readr for importing delimited text file
-   tidyr for tidying data 
-   dplyr for wrangling data
-   sf for handling geospatial data 

:::{.callout-note}
Among the four packages, readr, tidyr and dplyr are part of tidyverse package.So, we only need to install tidyverse instead of readr, tidyr and dplyr individually. 
:::

```{r}
#| code-fold: true
#| code-summary: "Show the code"
pacman::p_load(tidyverse, sf, tmap)
```

## Importing the Data into R 
For this exercise, we will use two datasets to create the choropleth map: 

-   Geospatial Data: Master Plan 2014 Subzone Boundary (Web) in ESRI shapefile format (`MP14_SUBZONE_WEB_PL`). It can be downloaded at [data.gov.sg](www.data.gov.sg).This dataset contains the geographical boundary of Singapore at the planning subzone level. The data is based on URA Master Plan 2014.

-   Aspatial Data: Singapore Residents by Planning Area/Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 in csv format (`respopagesextod2011to2020.csv`). It can be downloaded from [Department of Statistics, Singapore](https://www.singstat.gov.sg/). Although it does not contain any coordinates values, but it’s PA and SZ fields can be used as unique identifiers to geocode to `MP14_SUBZONE_WEB_PL` shapefile.


:::{.panel-tabset}
## Geospatial Data 
The code chunk below uses the `st_read()` function of `sf` package to import `MP14_SUBZONE_WEB_PL` shapefile into R as a simple feature data frame called `mpsz`.

```{r}
mpsz <- st_read(dsn = "data/geospatial",
                layer = "MP14_SUBZONE_WEB_PL")

mpsz
```
The message above also tells us that mpsz’s geometry type is multipolygon, there are a total of 323 multipolygon features and 15 fields in mpsz and it is in svy21 projected coordinates systems.


## Aspatial Data 

We will import `respopagesextod2011to2020.csv` file using `read_csv()` function of `readr` package. 

```{r}
popdata <- read_csv("data/aspatial/respopagesextod2011to2020.csv")

head(popdata)

```
From the above output, we see that there are 7 columns in the datatable, namely: Planning area (PA), Subzone (SZ), Age Group (AG), Sex, Type of Dwelling (TOD), Population (Pop), Year (Time). 

:::


## Data Preparation 
Before a thematic map can be prepared, we need to prepare a data table with year 2020 values. The data table should include the variables: PA, SZ, YOUNG(AG 0 to 4 until AG 20 to 24), ECONOMY ACTIVE (AG 25 to 29 until AG 60 - 64), AGED (AG 65 and above), TOTAL (All AG), DEPENDENCY (ratio between young and aged against economy active group).

### Data Wrangling

:::{.panel-tabset}

First, we will filter the data from year 2020, summarise the population count by grouping at PA, SZ and AG levels. 
Then we will pivot the table using pivot_wider so that the rows become columns. 

## Transforming the Data 
```{r}
popdata2020 <- popdata %>%
  filter(Time == 2020) %>%
  group_by(PA, SZ, AG) %>%
  summarise(Pop = sum(Pop)) %>%
  ungroup() %>%
  pivot_wider(names_from = AG, 
               values_from = Pop) 

glimpse(popdata2020)
```
## Data Table 

```{r}
head(popdata2020, 10)

```
::: 

Then we will group the various AG to create YOUNG, ECONOMY ACTIVE, AGED, TOTAL and also calculate the ratio DEPENDENCY using `mutate()` of `dplyr` package. 

:::{.panel-tabset}

## Transforming the Data 
```{r}
popdata2020 <- popdata2020 %>%
  mutate(YOUNG = rowSums(.[3:6]) + rowSums(.[14])) %>%
  mutate(ECONOMYACTIVE = rowSums(.[7:13]) + rowSums(.[15])) %>%
  mutate(AGED = rowSums(.[16:21])) %>%
  mutate(TOTAL = rowSums(.[3:21])) %>%
  mutate(DEPENDENCY = (YOUNG + AGED) / ECONOMYACTIVE) %>%
  select(PA, SZ, YOUNG, ECONOMYACTIVE, AGED, TOTAL, DEPENDENCY)

```
## Data Table 

```{r}
head(popdata2020, 10)

```
:::

### Joining the aspatial data and geospatial data
Before we can perform the georelational join, we need to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase. We will also retain those rows where 
ECONOMYACTIVE is more than 0 using `filter()`.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

popdata2020 <- popdata2020 %>%
  mutate_at(.vars = vars(PA, SZ), 
          .funs = funs(toupper)) %>%
  filter(ECONOMYACTIVE > 0)

```
Then we will use `left_join()` of dplyr to join the geospatial and aspatial data using planning subzone name (i.e. SUBZONE_N and SZ) as the common identifier. 

```{r}
#| code-fold: true
#| code-summary: "Show the code"

mpsz_pop2020 <- left_join(mpsz, popdata2020,
                          by = c("SUBZONE_N" = "SZ"))

```

:::{.callout-note}
Note! The mpsz simple feature data frame is the left data table in the left_join. This is to ensure that the output will be a simple features data frame.

::: 

Then we will write mpsz_pop2020 into an rds file for easy retrieval in future. 

```{r}
#| code-fold: true
#| code-summary: "Show the code"

write_rds(mpsz_pop2020, "data/rds/mpszpop2020.rds")

```

# Choropleth Mapping Geospatial Data using tmap 
Two approaches can be used to prepare thematic map using tmap, they are:

-   Plotting a thematic map quickly by using qtm().
-   Plotting highly customisable thematic map by using tmap elements.

## Plotting a choropleth map quickly using qtm()

:::{.panel-tabset}
## Static Map 
```{r}
tmap_mode("plot")
qtm(mpsz_pop2020, 
    fill = "DEPENDENCY")
```

## Interactive Map 

```{r}
tmap_options(check.and.fix = TRUE)
tmap_mode("view")
qtm(mpsz_pop2020, fill = "DEPENDENCY")

```
:::

Things to learn from the code chunks above:

`tmap_mode()` with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.
`fill` argument is used to map the attribute (i.e. DEPENDENCY)

## Creating a choropleth map using tmap's elements

### Drawing a base map 

The basic building block of tmap is `tm_shape()` followed by one or more layer elemments such as `tm_fill()` and `tm_polygons()`.

In the code chunk below, `tm_shape()` is used to define the input data (i.e `mpsz_pop2020`) and `tm_polygons()` is used to draw the planning subzone polygons.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

tmap_mode("plot")
tm_shape(mpsz_pop2020) +
  tm_polygons()
```

### Drawing a choropleth map using tm_polygons() 
To draw a choropleth map showing the geographical distribution of a selected variable by planning subzone, we need to assign the target variable such as `Dependency` to `tm_polygons()`.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

tm_shape(mpsz_pop2020) +
  tm_polygons("DEPENDENCY")
```
:::{.callout-note}

-   The default interval binning used to draw the choropleth map is called “pretty”. A detailed discussion of the data classification methods supported by tmap will be provided in the following section. 

-   The default colour scheme used is `YlOrRd` of ColorBrewer. We will learn how to change the colour scheme in the subsequent sections. 

-   By default, missing values will be shaded in grey. 

:::


### Drawing a choropleth map using tm_fill() and tm_border()
`tm_polygons()` is a wraper of `tm_fill()` and `tm_border()`. `tm_fill()` shades the polygons by using the default colour scheme and `tm_borders()` adds the borders of the shapefile onto the choropleth map.

The following code chunk draws a choropleth map using `tm_fill()` only. 

```{r}
#| code-fold: true
#| code-summary: "Show the code"

tm_shape(mpsz_pop2020) +
  tm_fill("DEPENDENCY")
```

:::{.callout-note}
Notice from the above output, there are no borders when only `tm_fill()` is used. 
:::

To add the boundary of the planning subzones, `tm_borders()` will be used.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

tm_shape(mpsz_pop2020) +
  tm_fill("DEPENDENCY") +
  tm_borders(lwd = 0.1, alpha = 1)
```

:::{.callout-note}
We added light grey border lines on the choropleth map using the above code chunk. 

The alpha argument is used to define transparency number between 0 (totally transparent) and 1 (not transparent). By default, the alpha value of the colour used is 1. 

There are three other arguments for tm_borders():
-   col: border color
-   lwd: border line width. The default is 1. 
-   lty: border line type. The default is "solid". 
:::

### Data Classification Methods of tmap 
Most choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes.

tmap provides a total ten data classification methods, namely: *fixed*, *sd*, *equal*, *pretty* (default), *quantile*, *kmeans*, *hclust*, *bclust*, *fisher*, and *jenks*.

We can define a data classification method using the `style` argument of `tm_fill()` or `tm_polygons()`. 

#### Plotting choropleth maps with built-in classification methods

:::{.panel-tabset}
## Jenks 
The following code chunk uses `jenks` data classification. We specify the number of classes to be broken into using `n = 5` to group the observations into 5 classes. 

```{r}

tm_shape(mpsz_pop2020) +
  tm_fill("DEPENDENCY",
          n = 5, 
          style = "jenks") +
  tm_borders(alpha = 0.5)

```
## Equal 
The following code chunk uses `equal` data classification. We specify the number of classes to be broken into using `n = 5` to group the observations into 5 classes. 
```{r}
tm_shape(mpsz_pop2020) +
  tm_fill("DEPENDENCY",
          n = 5, 
          style = "equal") +
  tm_borders(alpha = 0.5)

```
## quantile
The following code chunk uses `quantile` data classification. We specify the number of classes to be broken into using `n = 5` to group the observations into 5 classes. 
```{r}
tm_shape(mpsz_pop2020) +
  tm_fill("DEPENDENCY",
          n = 5, 
          style = "quantile") +
  tm_borders(alpha = 0.5)

```
:::

:::{.callout-note}
From the above charts, we note that the distribution of different data classification methods lead to different visualisation output. For example, using the equal data classification method, it seemed that most areas had a low ratio except for one area due to it having a very dark shade of orange. In comparison, when the same data uses quantile or jenks data classification methods, the distribution seems more even.

#### Plotting choropleth map with custom breaks
For all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the `tm_fill()`. It is important to note that, in tmap the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).

Before we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of `DEPENDENCY` field. 

```{r}
#| code-fold: true
#| code-summary: "Show the code"

summary(mpsz_pop2020$DEPENDENCY)
```

Based on the above results, we set break point at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 100. Our breaks vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 1.00). 


```{r}
#| code-fold: true
#| code-summary: "Show the code"

tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00)) +
  tm_borders(alpha = 0.5)

``` 

### Color Scheme 
tmap supports colour ramps either defined by the user or a set of predefined colour ramps from the [RColorBrewer package](https://r-graph-gallery.com/38-rcolorbrewers-palettes.html).

#### Using ColourBrewer Palette
To change the colour, we assign the preferred colour to palette argument of `tm_fill()` as shown in the code chunks below.

:::{.panel-tabset}
## Using Blues 
```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 6,
          style = "quantile",
          palette = "Blues") +
  tm_borders(alpha = 0.5)

``` 

## Using Reds 
To reverse the colour shading, add a “-” prefix.
```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "-Reds") +
  tm_borders(alpha = 0.5)

```
:::

### Map Layouts 
Map layout refers to the combination of all map elements into a cohensive map. Map elements include among others the objects to be mapped, the title, the scale bar, the compass, margins and aspects ratios. Colour settings and data classification methods covered in the previous section relate to the palette and break-points are used to affect how the map looks.

#### Map Legend
In tmap, several legend options are provided to change the placement, format and appearance of the legend.In the following code chunk, we added a legend histogram using `legend.hist = TRUE`. adjusted the length height and width using `legend.height` and `legend.width`. We also specified the length position using `legend.position`. 
```{r}
#| code-fold: true
#| code-summary: "Show the code"

tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "jenks", 
          palette = "Greens", 
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone \n(Jenks classification)",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.45, 
            legend.width = 0.35,
            legend.outside = FALSE,
            legend.position = c("right", "bottom"),
            frame = FALSE) +
  tm_borders(alpha = 0.5)

```

#### Map Style 
tmap allows a wide variety of layout settings to be changed. They can be called by using `tmap_style()`.

The following map uses the classic style. 
```{r}
#| code-fold: true
#| code-summary: "Show the code"

tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "-Greens") +
  tm_borders(alpha = 0.5) +
  tmap_style("classic") +
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone \n(Quantile classification)",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.4, 
            legend.width = 0.35,)

```
#### Cartographic Furniture
Beside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.

In the code chunk below, `tm_compass()`, `tm_scale_bar()` and `tm_grid()` are used to add compass, scale bar and grid lines onto the choropleth map.
```{r}
#| code-fold: true
#| code-summary: "Show the code"

tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues",
          title = "No. of persons") +
  tm_layout(main.title = "Distribution of Dependency Ratio \nby planning subzone",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.4, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```

To reset to the default style, we changed the style to `white`. 
```{r}
#| code-fold: true
#| code-summary: "Show the code"

tmap_style("white")
```

### Drawing Multiple Small Choropleth Maps
Small multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.

In tmap, small multiple maps can be plotted in three ways:
-   by assigning multiple values to at least one of the asthetic arguments,
-   by defining a group-by variable in `tm_facets()`, and
-   by creating multiple stand-alone maps with `tmap_arrange()`.

#### By assigning multiple values to at least one of the aesthetic arguments
In the following code chunk, small multiple choropleth maps are created by defining `ncols` in `tm_fill()`.
```{r}
#| code-fold: true
#| code-summary: "Show the code"

tm_shape(mpsz_pop2020) + 
  tm_fill(c("YOUNG", "AGED"),
          style = "equal",
          palette = "Blues") +  
  tm_borders(alpha = 0.5) + 
  tm_layout(main.title = "Distribution of Young and Old",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.4, 
            legend.width = 0.35,
            legend.position = c("right", "bottom"),
            frame = TRUE)
```

In the following example, multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments. We can also define different data classification and different colour schemes by assigning multiple values. 

```{r}
#| code-fold: true
#| code-summary: "Show the code"

tm_shape(mpsz_pop2020) +
  tm_polygons(c("DEPENDENCY", "AGED"),
              style = c("equal", "quantile"),
              palette = list("Blues", "Greens")) +
   tm_layout(main.title = "Distribution of Young and Old",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.4, 
            legend.width = 0.35,
            legend.position = c("right", "bottom"),
            frame = TRUE)

```
#### By defining a group-by variable in tm_facets()

In the following example, multiple choropleth maps are created using `tm_facets()`. 

```{r}
#| code-fold: true
#| code-summary: "Show the code"

tm_shape(mpsz_pop2020) +
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "Greens",
          thres.poly = 0) + 
  tm_facets(by="REGION_N", 
            free.coords=TRUE, 
            drop.shapes=FALSE) +
  tm_layout(main.title = "Dependency Ratio by Regions",
            main.title.size = 1,
            legend.show = FALSE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(alpha = 0.5) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))

```

#### By creating multiple stand-alone maps with tmap_arrange()
In the following code chunk. multiple choropleth maps are created by first creating multiple stand-alone maps then arranged them together with `tmap_arrange()`. This is akin to how we use patchwork to arrange several ggplots together. 

```{r}
#| code-fold: true
#| code-summary: "Show the code"

youngmap <- tm_shape(mpsz_pop2020) +
  tm_polygons("YOUNG",
              style = "quantile",
              palette = "Reds") +
   tm_layout(legend.height = 0.4, 
            legend.width = 0.35,
            legend.position = c("right", "bottom"),
            frame = TRUE)
  

agedmap <- tm_shape(mpsz_pop2020) +
  tm_polygons("AGED",
              style = "quantile",
              palette = "Reds") +
   tm_layout(legend.height = 0.4, 
            legend.width = 0.35,
            legend.position = c("right", "bottom"),
            frame = TRUE)

tmap_arrange(youngmap, agedmap, asp = 1, ncol = 2)
```

### Mapping Spatial Object Meeting a Selection Criterion 

Instead of creating small multiple choropleth map, you can also use selection function to map spatial objects meeting the selection criterion.

In the following code chunk, we define the selection using `tm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N=="CENTRAL REGION", ])` to only plot out the Central Region and its dependency ratio. 

```{r}
#| code-fold: true
#| code-summary: "Show the code"

tm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N=="CENTRAL REGION", ])+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues", 
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_layout(legend.outside = TRUE,
            legend.height = 0.45, 
            legend.width = 5.0,
            legend.position = c("right", "bottom"),
            frame = FALSE) +
  tm_borders(alpha = 0.5)
```

